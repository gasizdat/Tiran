<img src="http://habrastorage.org/storage2/d96/b35/156/d96b351565a2abcbfcbfe3b2d9795a9c.png" align="left" alt="image"/>Не так давно мне стало любопытно, насколько сносно современные браузеры поддерживают HTML5 и я не нашел лучшего 
способа, чем написать простейший 2D платформер. Помимо удовольствия от разработки игрушки и улучшения навыков в использовании JavaScript, в ходе <s>развлечения</s> кропотливой работы был накоплен определенный опыт и эмпирическим путем были найдены основные грабли, на многие из которых мне пришлось наступить. В этой статье я попробую кратко и с примерами резюмировать то, что вынес для себя из проделанной работы. Желающих создать свое высокопроизводительное JavaScript приложение, эффективно работающее с графикой, прошу под кат.
<habracut />
<h4>Общие замечания</h4>
Код на JavaScript очень критичен к ресурсам платформы. Несмотря, что почти все современные движки перестали тупо интерпретировать JS код, скорость его выполнения по-прежнему очень сильно уступает скорости «родного» кода. Между тем, даже простейшая игра - это много кода, который должен успевать выполниться между отрисовками двух соседних кадров анимации. Кроме того, JS - язык весьма специфический и написание объемного кода на нем сопряжено с рядом трудностей. Все вместе может стать причиной того, что приложение на JS перестанет удовлетворять ожиданиям и быстро <a href="http://habrahabr.ru/post/151337/">принесет разочарование</a>. Попробую немного систематизировать выводы, к которым я пришел путем экспериментов.

<h5>1. Совместимость</h5>Если мы решили использовать HTML5 и Canvas в частности, то пусть нас больше не беспокоят вопросы совместимости со старыми браузерами – под ними все равно ничего не заработает. Таким образом, можно смело использовать основные нововведения ECMAScript 5. С другой стороны, не стоит обижать презрением пользователей старого доброго ПО, наподобие IE6. Желательно их уведомить, о причинах, почему они видят фигу серый квадрат, вместо нашей замечательной анимации. Сделать это элементарно, достаточно диагностировать поддержку Canvas и используемых языковых конструкций 

<source lang="HTML">
<canvas id="gameArea">
  <span style="color:red">Your browser doesn't supported HTML5 Canvas</span>
</canvas>

<script type="text/javascript">
(function(){
if(typeof ({}.__defineGetter__) != "function" && typeof (Object.defineProperty) != "function")
  alert("Your browser doesn't supported latest JavaScript version");})()
</script>
</source>
Все бы хорошо, да вот беда – проблемы кроссбраузерной совместимости до конца не исчерпаны. Среди современных браузеров нет единого мнения насчет названий стандартных функций. Выход – либо вообще отказаться от их использования, либо делать дорогостоящие адаптеры. Например, я не смог отказать себе в использовании описателей свойств и это дало свои негативные последствия. О том, как их использовать кроссбраузерно, хорошо описано <a href="http://habrahabr.ru/post/117803/">здесь</a>, и <a href="http://habrahabr.ru/post/108295/">здесь</a>. А вот как их заставить работать быстро - осталось загадкой.

<h5>2. Оптимизацию кода легко сломать</h5>Не так давно на Хабре проскакивала очень полезная статья про <a href="http://habrahabr.ru/post/154537/">движок V8 для Chromium</a>. Самое главное, что я сумел почерпнуть для себя – это скрытые классы и оптимизация кода для работы с ними. Действительно, JS зачастую провоцирует менять структуру объекта после его конструирования. Не стоит этого делать, если цель – создать быстрый и легко поддерживаемый код. Как только я это осознал, работа над игрой пошла веселее, а код стал чище и быстрее. 

<source lang="JavaScript">
function myObject() { };
var mo = new myObject();
mo.id = 12; //лучше так не делать
//Аккуратнее надо быть и с переменными.
var v;
v = 12; //плохо, лучше var v = 12;
v = “12”; //так не надо, для нового типа лучше использовать новую переменную
var v = 15; //я искренне верю, что так никто не поступает
</source>
Так же нужно стремиться сокращать область видимости переменной до минимума – это увеличивает вероятность оптимизации кода.

<h5>3. В JS нет классов, наследования и прочего класс-ориентированного программирования. </h5>Не следует напрягать движок реализацией классов при помощи прототипирования – выгода сомнительна, а код замедляется в разы (Opera)! Сложное прототипное наследование и честно организованный перенос базового функционала к наследникам сбивают и без того не самую лучшую оптимизацию.

<h5>4. Платим за то, что используем</h5>По ходу разработки игры или любого другого ресурсоемкого приложения, неизбежно приходится кэшировать «дорогие» ресурсы, например, предрасчитанные анимации или динамически загружаемые скрипты. У любого ресурса есть время жизни, после которого он оказывается не нужен. И тут важно правильно от него избавиться.

<source lang="JavaScript">
var resCache = { res1 : new getCostlyResource() }//тут может быть выделено много памяти
resCache.res1 = null; 
</source>
Скорее всего, память не будет освобождена сборщиком мусора (GC). Она будет собрана в произвольный момент времени, и он окажется самым неподходящим, потому что GC постарается удалить весь мусор, который накопится к этому моменту. Вот так уже лучше:

<source lang="JavaScript">
delete resCache.res1;
resCache.res1 = null; //полезно для отладки
</source>
На первый взгляд – ничего сложного, но в более сложных случаях появляются нюансы, и поведение delete <a href="http://habrahabr.ru/post/150723/">не всегда очевидно</a>. 

<h5>5. Замыкания и свойства – враги быстродействия</h5>Замыкания – базовая возможность функционального языка. Кажется, что именно это место должно быть максимально оптимизировано движком JS. Но, практика показывает, что это не так. Вот <b><a href="http://gasizdat.narod.ru/projects/game2/h.html#/map 1000">небольшой тест</a></b>, который сравнивает быстродействие различных способов доступа к данным объекта (<a href="https://tiran.googlecode.com/svn/trunk/lvl1000.js">код теста</a>).
Результат для разных браузеров и платформ (мс):
<table >
<tr>
<th>Windows XP (x86), Core 2 Duo, 3 GHz</th><th>Opera 12</th><th>FireFox 17</th><th>Chrome 23</th>
</tr>
<tr>
<td>Нет замыканий, прямой доступ к полям объекта</td><td>9</td><td>6</td><td>17</td>
</tr>
<tr>
<td>Нет замыканий, доступ к данным через методы</td><td>16</td><td>11</td><td>28</td>
</tr>
<tr>
<td>Замыкания, доступ через методы</td><td>34</td><td>12</td><td>23</td>
</tr>
<tr>
<td>Замыкания, доступ через свойства</td><td>387</td><td>899</td><td>489</td>
</tr>
</table><table >
<tr>
<th>Windows 7 (x64), Core i3-2100, 3.1 GHz</th><th>Opera 12</th><th>Chrome 23</th><th>IE 10</th>
</tr>
<tr>
<td>Нет замыканий, прямой доступ к полям объекта</td><td>7</td><td>5</td><td>15</td>
</tr>
<tr>
<td>Нет замыканий, доступ к данным через методы</td><td>13</td><td>11</td><td>13</td>
</tr>
<tr>
<td>Замыкания, доступ через методы</td><td>27</td><td>9</td><td>14</td>
</tr>
<tr>
<td>Замыкания, доступ через свойства</td><td>222</td><td>315</td><td>99</td>
</tr>
</table>Как ни удивительно, Opera смотрится в тесте лучше других. К сожалению, общий вывод неутешителен, замыкания оптимизированы только в Chrome, а доступ через свойства – это большая роскошь, способная на порядок ухудшить быстродействие приложения.

<h4>Замечания о графическом движке </h4>
Программирование графики на JavaScript - отдельная большая тема, которую могу затронуть позже, если будет спрос. Здесь я постарался выделить несколько простых приемов, которые было легко использовать и они дали неплохой результат.

<h5>1. Покадровая анимация.</h5>Есть два подхода к созданию анимации: событийный и покадровый. Первый пригоден в основном для простых задач, наподобие подсветки кнопки при наведении мышки и может выполняться в соответствующих обработчиках. Второй годится для выполнения сложных анимационных задач, которые должны «жить своей жизнью», вне зависимости от действий пользователя, например, динамические игры.
При создании игры проще всего (и дешевле в плане вычислительных ресурсов) рассчитывать игровой процесс, полагаясь на стабильность частоты кадров (frame). Можно попытаться использовать <a href="https://developer.mozilla.org/ru/docs/DOM/window.requestAnimationFrame">запрос кадра анимации</a> у тех браузеров, что его поддерживают. Сделать это не так просто, потому что этот метод стал стандартом де-факто и по какой-то причине не попал в ECMAScript 5.

<source lang="JavaScript">var raf = window.requestAnimationFrame || window.msRequestAnimationFrame ||      window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
И использовать его можно примерно так:
var myRedrawFunc = function () { /*тут мог бы быть ваш код*/ raf(myRedrawFunc) }
raf(myRedrawFunc);
</source>
Выгода RequestAnimationFrame в основном состоит в том, что при ненагруженной анимации (когда сам процесс отрисовки занимает меньше половины времени кадра), он позволяет добиться большей плавности анимации и сокращает потребление ресурсов на мобильных платформах. Но на деле это может оказаться не так. К неудобствам от его использования можно отнести фиксированную частоту кадров (60 fps) и отсутствие компенсации продолжительности следующего кадра, если задержалась отрисовка предыдущего.
Однако, что делать, если raf === null? Так может произойти, если ваше приложение попало в руки Opera, которая традиционно идет своим путем. Тогда нам поможет старый добрый setTimeout. В итоге код будет выглядеть примерно так:

<source lang="JavaScript">var fps = 60;
var frameTimeCorrection = 0;
var lastFrameTime = new Date();
var to = 1000/fps;
var myRedrawFunc = function()
{
  /* Код анимации и физического движка */
  var now_time = new Date();
  frameTimeCorrection += now_time - lastFrameTime - to;
  if(frameTimeCorrection >= to)
    frameTimeCorrection = to - 1; //ограничиваем большую коррекцию
  lastFrameTime = now_time;
 
  if(raf)
    raf(redrawFunc);
  else
    setTimeout(myRedrawFunc, to - frameTimeCorrection);
};
myRedrawFunc ();</source>
Недостаток у такого подхода очевиден – если расчёт кадров будет подтормаживать больше, чем можно скорректировать – игровой процесс перестанет рассчитываться в реальном времени. Но можно пойти на хитрость. Как правило, причина тормозов - отрисовка элементов очередного кадра, т.к. для движка браузера это накладная операция. Поэтому можно написать код так, что в случае, когда коррекция времени не справляется (срабатывает условие if(frameTimeCorrection >= to)), в следующем кадре можно производить только расчет игрового мира без его перерисовки. Появится т.н. «<a href="http://ru.wikipedia.org/wiki/Лаг_(компьютерный_сленг)">лаг</a>» который в игре выглядит менее раздражающе, чем slow motion.

<h5>2. Рисуем только то, что видно на холсте.</h5>Наиболее простой и проверенный годами способ анимации – <a href="http://ru.wikipedia.org/wiki/Спрайт_(компьютерная_графика)">спрайты</a>. Особенность этого способа заключается в том, что для создания иллюзии движения, спрайты перемещаются в игровом пространстве, путем изменения координат их отрисовки. Как правило, игровое пространство значительно превышает по размеру область отрисовки кадра и если игровое пространство большое, и спрайтов много их отрисовка станет занимать ощутимое время. Методы контекста канвы являются элементами DOM, а обращение к ним весьма накладно. Одна из оптимизаций заключается в том, чтобы рисовать только то, что видно в кадре. В <b><a href="http://gasizdat.narod.ru/projects/game2/h.html#/map 1001">приведенном тесте</a></b>, вначале создаются и выводятся на канву 9000 «умных» спрайтов, которые при перерисовке следят за своими координатами, и не обращаются к методам канвы, если они вне кадра. Затем создаются 9000 «глупых» спрайтов, которые не следят за областью видимости (<a href="https://tiran.googlecode.com/svn/trunk/lvl1001.js">код теста</a>).
Результаты теста (fps):
<table >
<tr>
<th>Windows XP (x86), Core 2 Duo, 3 GHz</th><th>Opera 12</th><th>FireFox 17</th><th>Chrome 23</th>
</tr>
<tr>
<td>«Умные» спрайты</td><td>47</td><td>35</td><td>25</td>
</tr>
<tr>
<td>«Глупые» спрайты</td><td>15</td><td>14</td><td>12</td>
</tr>
</table ><table >
<tr>
<th>Windows 7 (x64), Core i3-2100, 3.1 GHz</th><th>Opera 12</th><th>Chrome 23</th><th>IE 10</th>
</tr>
<tr>
<td>«Умные» спрайты</td><td>56</td><td>32</td><td>61</td>
</tr>
<tr><td>«Глупые» спрайты</td><td>19</td><td>15</td><td>51</td>
</tr>
</table >

Разница ощутима (а Хром<s>ой</s> снова подкачал – миф развенчан).

<h5>3. Кэшируем <a href="http://ru.wikipedia.org/wiki/Растеризация">растеризацию</a></h5>Растеризация средствами графического движка – довольно ресурсоемкое занятие. Поэтому важной оптимизацией является кэширование результатов растеризации в памяти. Самый простой способ – создать отдельную канву и в ней растеризовать векторную графику. Запомнить указатель на нее в кэше и в основной области отрисовки выводить запомненный результат. Для иллюстрации возьмем растеризацию 1000 текстовых спрайтов. В <b><a href="http://gasizdat.narod.ru/projects/game2/h.html#/map 1002">тесте производительности </a></b>, попеременно с интервалом 20 сек отрисовываются 800 текстовых спрайтов. Вначале с кэшированием результата растеризации, затем без кэширования (<a href="https://tiran.googlecode.com/svn/trunk/lvl1002.js">код теста</a>).
Результаты теста (fps):<table >
<tr>
<th>Windows XP (x86), Core 2 Duo, 3 GHz</th><th>Opera 12</th><th>FireFox 17</th><th>Chrome 23</th>
</tr>
<tr>
<td>Кэширование растеризации</td><td>23</td><td>32</td><td>60</td>
</tr>
<tr>
<td>Без кэширования</td><td>5</td><td>12</td><td>47</td>
</tr>
</table ><table >
<tr>
<th>Windows 7 (x64), Core i3-2100, 3.1 GHz</th><th>Opera 12</th><th>Chrome 23</th><th>IE 10</th>
</tr>
<tr>
<td>Кэширование растеризации</td><td>33</td><td>61</td><td>61</td>
</tr>
<tr><td>Без кэширования</td><td>5</td><td>56</td><td>23</td>
</tr>
</table >При таком подходе важно соблюдать баланс между памятью, частотой сброса кэша и быстродействием растеризации. Так, если текст меняется динамически и довольно интенсивно (скажем, раз в 10 кадров анимации), то его кэширование может только ухудшить общее быстродействие, т.к. сама операция кэширования будет вносить больше накладных расходов, чем растеризация.

<h5>4. Динамическая загрузка ресурсов</h5>Если анимация строится на спрайтах из битовых карт (bitmap), то прежде, чем их можно будет рисовать на холсте, следует загрузить эти самые карты в кэш изображений браузера. Для этого достаточно создать элемент Image и в качестве источника передать url ресурса картинки. Сложность состоит в том, чтобы дождаться момента, когда браузер загрузит картинку в свой кэш. Для этого можно использовать событие onload, в котором, увеличивать счетчик уже загруженных картинок. Как только значение это счетчика совпадет с числом картинок, добавленных к загрузке, ресурс станет персистентным, и мы можем выполнять основной игровой код. 

<source lang="JavaScript">
function Cache()
{
  var imgs = {};
  var _addedImageCount = 0;
  var _loadedImgsCount = 0;
  this.addSpriteSource = function(src)
  {
    var img = new Image();
    img.onload = function()
    {
      _loadedImgsCount++;
    };
    img.src = src;
    imgs[src] = img;
    _addedImageCount++;
  }
  this.getLoadedImagePc()
  {
    return _loadedImgsCount * 100 / _addedImageCount;
  }
}
//добавляем картинки
Cache. addSpriteSource("img1.jpg");
Cache. addSpriteSource("img2.jpg");
//ждем, пока они загрузятся
function waitImagesLoading()
{
  var pc = Cache. getLoadedImagePc();
  if(pc < 100)
    setTimeout(waitImagesLoading, 200);
  /* при необходимости тут можно анимировать процент загрузки картинок*/
}
waitImagesLoading();
</source>
В своей игрушке я решил каждый уровень описывать отдельным скриптовым файлом. Понятно, что статическая загрузка таких скриптов вредна, т.к. в каждый момент времени нужен только один из них. Решению задачи помог тот же подход, что и в случае загрузки изображений. 
Есть только один нюанс - у объекта Script нет событий, но это и не беда, т.к. в код динамически загружаемых скриптов можно вставить глобальную функцию регистрации скрипта в кэше. Дальше поступаем аналогично загрузке картинок - асинхронно ждем, пока скрипт зарегистрирует описанные в нем типы, а затем создаем нужные нам экземпляры зарегистрированных типов.
Для того чтобы пользователь не скучал - можно показать процент загрузки всех необходимых ресурсов.

<h5>5. Дробные координаты</h5>Рисуя на канве растровые или векторные примитивы, можно указывать дробные координаты и размеры. В результате графический движок браузера вынужден сглаживать выводимое на экран изображение. Если упрощать, то это происходит, потому что виртуальный пиксель растеризованного изображения не будет совпадать с пикселем на экране. Как результат - включатся алгоритмы  сглаживания изображения (smoothing), что может заметно сказаться на производительности.
В <b><a href="http://gasizdat.narod.ru/projects/game2/h.html#/map 1003">тесте производительности</a> </b>, попеременно с интервалом 20 сек спрайты с целыми и с дробными координатами (<a href="https://tiran.googlecode.com/svn/trunk/lvl1003.js">код теста</a>).
Результаты теста (fps):
<table>
<tr>
<th>Windows XP (x86), Core 2 Duo, 3 GHz</th><th>Opera 12</th><th>FireFox 17</th><th>Chrome 23</th>
</tr>
<tr>
<td>Целые координаты и размеры</td><td>57</td><td>60</td><td>60</td>
</tr>
<tr>
<td>Дробные координаты и размеры</td><td>50</td><td>52</td><td>60</td>
</tr>
</table ><table >
<tr>
<th>Windows 7 (x64), Core i3-2100, 3.1 GHz</th><th>Opera 12</th><th>Chrome 23</th><th>IE 10</th>
</tr>
<tr>
<td>Целые координаты и размеры</td><td>60</td><td>61</td><td>61</td>
</tr>
<tr>
<td>Дробные координаты и размеры</td><td>60</td><td>61</td><td>61</td>
</tr>
</table > Тут следует пояснить, что в случае 64-битной платформы положение спасает более хороший графический адаптер, который очевидно берет на себя задачу сглаживания и антиалиасинга.  В случае относительно быстро перемещаемых спрайтов (десятки пикселов за секунду) можно обходиться целыми координатами и размерами. Однако сами координаты и размеры нужно считать в дробных величинах, чтобы не терять точность при плавном изменении параметров. Вполне оправдывает себя такой подход, когда все значения координат и размеров рассчитываются и хранятся без округлений, а перед непосредственным выводом на канву, они округляются с помощью Math.floor.

<h4>Вместо заключения.</h4>Современное развитие JavaScript, HTML5 и поддержка этих возможностей различными браузерами уже вполне позволяют писать производительные интерактивные графические приложения, которые в большинстве задач дадут фору традиционному flash программированию. 